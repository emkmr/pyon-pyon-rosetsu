<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>pyon„É≠„Çª„ÉÑ</title>
<link rel="icon" type="image/png" href="assets/home-icon.png">
<link rel="apple-touch-icon" href="assets/home-icon.png">
<meta name="apple-mobile-web-app-title" content="pyon„É≠„Çª„ÉÑ">
<link rel="preload" as="image" href="assets/pyon-pyon-rosetsu:assets:ref:ui_reference_01.png">
<style>
@import url('https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@700&display=swap');

:root {
  --ground-color: #FCF07A;
  --ground-dark-color: #FCF07A;
}

body {
  margin: 0;
  padding: 0;
  background: linear-gradient(180deg, #f7e389 0%, #f7e389 15%, #e18448 15%, #e18448 85%, #f7e389 85%, #f7e389 100%);
  overflow: hidden;
  font-family: 'M PLUS Rounded 1c', sans-serif;
  touch-action: none;
  width: 100vw;
  height: 100vh;
}

#game-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

canvas {
  display: block;
  width: 100%;
  height: 100%;
}

#ui-layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}

.hud {
  padding-top: max(20px, env(safe-area-inset-top) + 20px);
  padding-left: max(20px, env(safe-area-inset-left) + 20px);
  padding-right: max(20px, env(safe-area-inset-right) + 20px);
  padding-bottom: 20px;
  width: 100%;
  max-width: 420px;
  margin: 0 auto;
  box-sizing: border-box;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  z-index: 100;
}

#score {
  font-size: 12px;
  color: rgba(51, 51, 51, 0.6);
  background: transparent;
  padding: 2px 0;
  font-weight: bold;
  letter-spacing: 0.08em;
  text-transform: uppercase;
}

#dist {
  font-size: 20px;
  color: #2a2620;
  font-weight: 700;
  text-shadow: none;
  background: none;
  border: none;
  padding: 0;
  margin-right: 6px;
}

#start-screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(247, 222, 143, 0.92);
  backdrop-filter: blur(12px);
  display: flex;
  justify-content: center;
  align-items: center;
  color: #333;
  z-index: 200;
  pointer-events: auto;
}

.start-btn {
  padding: 18px 60px;
  font-size: 18px;
  font-weight: bold;
  background: #1f1b1a;
  color: white;
  border: none;
  cursor: pointer;
  border-radius: 50px;
  box-shadow: 0 10px 20px rgba(0,0,0,0.1);
  transition: transform 0.2s, box-shadow 0.2s;
  font-family: inherit;
}

.start-btn:active {
  transform: scale(0.95);
  box-shadow: 0 5px 10px rgba(0,0,0,0.1);
}

.overlay-card {
  width: min(360px, calc(100% - 40px));
  border-radius: 28px;
  border: 4px solid #2f4357;
  padding: 34px 26px 40px;
  background: #FFD9E6;
  box-shadow: 0 25px 40px rgba(0,0,0,0.2);
  text-align: center;
  color: #2c2c2c;
}

.overlay-caption {
  font-size: 14px;
  letter-spacing: 0.3em;
  color: rgba(33, 33, 33, 0.8);
  margin-bottom: 18px;
}

.overlay-scene {
  border-radius: 24px;
  border: 3px solid #1f2d40;
  overflow: hidden;
  margin: 0 auto 22px;
  width: min(320px, calc(100% - 40px));
  background: #8cc0f4;
  box-shadow: inset 0 0 0 2px rgba(0,0,0,0.05);
}

.overlay-video {
  width: min(320px, calc(100% - 40px));
  aspect-ratio: 16 / 9;
  margin: 0 auto 20px;
  background: #8cc0f4;
  border-radius: 24px;
  overflow: hidden;
  border: 3px solid #1f1b1a;
  box-shadow: 0 12px 20px rgba(0, 0, 0, 0.15);
  opacity: 0;
  transition: opacity 0.25s ease;
}

.overlay-video.is-ready {
  opacity: 1;
}

.overlay-video video {
  width: 100%;
  height: auto;
  display: block;
  object-fit: cover;
  width: 100%;
  height: 100%;
  opacity: 0;
  transition: opacity 0.25s ease;
}

.overlay-video video.is-ready {
  opacity: 1;
}

.overlay-scene-sky {
  background: #8cc0f4;
  padding: 18px 18px 26px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}

.overlay-scene-text {
  font-size: 10px;
  color: rgba(34,34,34,0.7);
  letter-spacing: 0.1em;
  margin: 0;
  width: min(320px, calc(100% - 40px));
  text-align: center;
}

.overlay-hand {
  width: 54px;
  height: 54px;
}

.overlay-hand svg {
  width: 100%;
  height: 100%;
}

.overlay-scene-ground {
  background: linear-gradient(0deg, var(--ground-color) 0%, var(--ground-color) 100%);
  padding: 12px 18px 16px;
  position: relative;
  min-height: 72px;
  display: flex;
  align-items: flex-end;
}

.overlay-dog {
  width: 78px;
  height: 78px;
  background: #ffd9e6 url('assets/pyon-pyon-rosetsu:assets:ref:ui_reference_01.png') center/contain no-repeat;
  border-radius: 16px;
  filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2));
}

.overlay-message {
  font-size: 32px;
  margin: 0;
  color: #2e2e2e;
}

.overlay-subhead {
  font-size: 16px;
  margin: 6px 0 0;
  color: rgba(34,34,34,0.7);
}

.overlay-subhead img {
  width: 24px;
  height: 24px;
  vertical-align: middle;
  margin-right: 6px;
  border-radius: 50%;
}

.overlay-score-panel {
  display: none;
  align-items: center;
  justify-content: center;
  gap: 14px;
  margin: 18px 0;
  color: #c67b1d;
}

.overlay-score-panel.visible {
  display: flex;
}

.overlay-star {
  font-size: 26px;
}

.overlay-score-text {
  font-size: 16px;
  line-height: 1.2;
}

.overlay-score-value {
  font-size: 36px;
  font-weight: 700;
  display: block;
  color: #2f2b27;
}

.overlay-subtext {
  font-size: 14px;
  color: rgba(33, 33, 33, 0.8);
  margin-bottom: 20px;
}

</style>
</head>

<body>
<div id="game-container">
  <canvas id="gameCanvas"></canvas>

  <div id="ui-layer">
    <div class="hud">
      <span id="score">SCORE: 0</span>
      <span id="dist">0</span>
    </div>
  </div>

  <div id="start-screen">
    <div class="overlay-card">
      <p class="overlay-caption">üçì„Å¥„Çá„Çì„Å¥„Çá„Çì„É≠„Çª„ÉÑüçì</p>
      <div class="overlay-video" id="overlay-video">
        <video src="assets/pyon-pyon-rosetsu:assets:img:ui_reference_04.mov" preload="none" loop muted playsinline webkit-playsinline></video>
      </div>
      <div class="overlay-scene" id="overlay-scene">
        <div class="overlay-scene-sky">
          <p class="overlay-scene-text">„Çø„ÉÉ„Éó„Åó„Å¶„Éó„É¨„Ç§</p>
          <div class="overlay-hand">
            <svg viewBox="0 0 64 64" fill="none" stroke="#555" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
              <path d="M20 26v-8a4 4 0 0 1 8 0v9"></path>
              <path d="M28 22v-6a4 4 0 0 1 8 0v10"></path>
              <path d="M36 24v-8a4 4 0 0 1 8 0v16"></path>
              <path d="M44 28v-6a4 4 0 0 1 8 0v20c0 8-6 14-14 14h-4"></path>
              <path d="M18 30c0 10 6 20 10 24"></path>
            </svg>
          </div>
        </div>
        <div class="overlay-scene-ground">
          <div class="overlay-dog" aria-hidden="true"></div>
        </div>
      </div>
      <h1 class="overlay-message" id="overlay-message"></h1>
      <p class="overlay-subhead" id="overlay-subhead"></p>

      <div class="overlay-score-panel" id="overlay-score-panel">
        <span class="overlay-star">‚ô°</span>
        <div class="overlay-score-text">
          <span>Score</span>
          <span class="overlay-score-value" id="overlay-score-value">0</span>
        </div>
        <span class="overlay-star">‚ô°</span>
      </div>

      <p class="overlay-subtext" id="overlay-subtext"></p>
      <button class="start-btn" id="start-btn">PLAY GAME</button>
    </div>
  </div>
</div>

<script>
/**
 * Game Setup
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const startScreenEl = document.getElementById('start-screen');
const overlayMessageEl = document.getElementById('overlay-message');
const overlayScene = document.getElementById('overlay-scene');
const overlayVideo = document.getElementById('overlay-video');
const overlayVideoEl = overlayVideo ? overlayVideo.querySelector('video') : null;
const overlayScorePanel = document.getElementById('overlay-score-panel');
const overlayScoreValue = document.getElementById('overlay-score-value');
const overlaySubtextEl = document.getElementById('overlay-subtext');
const overlaySubheadEl = document.getElementById('overlay-subhead');
const startBtn = document.getElementById('start-btn');
const scoreEl = document.getElementById('score');
const distEl = document.getElementById('dist');

if (overlayVideoEl) {
  const markVideoReady = () => {
    overlayVideoEl.classList.add('is-ready');
    overlayVideo.classList.add('is-ready');
  };
  overlayVideoEl.addEventListener('canplay', markVideoReady, { once: true });
  overlayVideoEl.addEventListener('loadeddata', markVideoReady, { once: true });
  overlayVideoEl.addEventListener('timeupdate', () => {
    if (!overlayVideoEl.duration || !Number.isFinite(overlayVideoEl.duration)) return;
    if (overlayVideoEl.currentTime >= overlayVideoEl.duration - 0.05) {
      overlayVideoEl.currentTime = 0.01;
      overlayVideoEl.play().catch(() => {});
    }
  });

  const startVideoPlayback = () => {
    if (overlayVideoEl.dataset.playRequested) return;
    overlayVideoEl.dataset.playRequested = 'true';
    const tryPlay = () => overlayVideoEl.play().catch(() => {});

    if (overlayVideoEl.readyState >= 2) {
      tryPlay();
      return;
    }

    overlayVideoEl.addEventListener('loadeddata', tryPlay, { once: true });
    overlayVideoEl.load();
  };

  if ('requestIdleCallback' in window) {
    window.requestIdleCallback(startVideoPlayback, { timeout: 700 });
  } else {
    window.setTimeout(startVideoPlayback, 500);
  }
}

const COLORS = {
  sky: '#FFD9E6',
  ground: '#FCF07A',
  groundDark: '#FCF07A',
  blockQ: '#98fb98',
  pipe: '#FF69B4',
  pipeDark: '#C71585',
  text: '#333333'
};

const INVINCIBLE_DURATION_FRAMES = 60 * 5;
const RABBIT_SPAWN_CHANCE = 0.28;
const RABBIT_EMERGE_FRAMES = 18;
const BIG_BANG_DURATION_FRAMES = 90;
const BASEBALL_STORM_FRAMES = 90;
const DOG_COOLDOWN_FRAMES = 60 * 30;

// ‚òÖ „Éû„ÉÉ„Éó„ÅÆÁ∏¶„Éû„ÇπÊï∞Ôºày=0..14 „Å®‰∏ÄËá¥Ôºâ
const ROWS = 15;

// ÁîªÈù¢ÔºàCSS„Éî„ÇØ„Çª„É´Âü∫Ê∫ñÔºâ
const view = { w: 0, h: 0, dpr: 1 };

// „Ç≤„Éº„É†ÂÆöÊï∞ÔºàÂàùÊúüÂÄ§Ôºâ
let TILE_SIZE = 40;
let GRAVITY = 0.6;
let JUMP_FORCE = -12;
let MOVE_SPEED = 5;

let gameState = {
  isRunning: false,
  score: 0,
  distance: 0,
  cameraX: 0
};

let jumpPressed = false;
let bigBangTimer = 0;
let baseballStorm = null;
let dogSpawnCooldown = 0;

/**
 * Resize Logic
 */
function getViewportSize() {
  // iOS Safari „ÅÆ„Ç¢„Éâ„É¨„Çπ„Éê„Éº‰º∏Á∏ÆÂØæÁ≠ñ
  const vv = window.visualViewport;
  const w = Math.floor(vv?.width ?? window.innerWidth);
  const h = Math.floor(vv?.height ?? window.innerHeight);
  return { w, h };
}

function calculateConstants() {
  // ‚òÖ ROWS (=15) „Å®‰∏ÄËá¥„Åï„Åõ„Å¶ tile „ÇíË®àÁÆó„Åô„ÇãÔºàÂ∫ä„ÅåË¶ã„Åà„Å™„ÅÑ„ÅÆ„Å´ÂΩì„Åü„ÇäÂà§ÂÆö„Å†„Åë„ÅÇ„ÇãÂïèÈ°å„ÅÆ‰∏ªÂõ†„ÇíÈô§ÂéªÔºâ
  TILE_SIZE = Math.max(24, Math.floor(view.h / ROWS));

  GRAVITY = TILE_SIZE * 0.03;
  JUMP_FORCE = -(TILE_SIZE * 0.55);
  MOVE_SPEED = TILE_SIZE * 0.12;
}

function resize() {
  const { w, h } = getViewportSize();
  view.w = w;
  view.h = h;
  view.dpr = window.devicePixelRatio || 1;

  // Ë¶ã„ÅüÁõÆ„Çµ„Ç§„Ç∫
  canvas.style.width = w + "px";
  canvas.style.height = h + "px";

  // ÂÆü„Éî„ÇØ„Çª„É´ÔºàÊèèÁîª„Éê„ÉÉ„Éï„Ç°Ôºâ
  canvas.width = Math.floor(w * view.dpr);
  canvas.height = Math.floor(h * view.dpr);

  // Â∫ßÊ®ôÁ≥ª„ÅØ CSS„Éî„ÇØ„Çª„É´„ÅßÊâ±„Åà„Çã„Çà„ÅÜ„Å´„Åô„Çã
  ctx.setTransform(view.dpr, 0, 0, view.dpr, 0, 0);

  if (!gameState.isRunning) {
    calculateConstants();
  }
}

window.addEventListener('resize', resize);
if (window.visualViewport) window.visualViewport.addEventListener('resize', resize);
resize();

/**
 * Drawing Functions
 */
function drawPlayer(ctx, x, y, frame) {
  const drawW = player.w * 1.4;
  const drawH = player.h * 1.2;
  const centerX = x + player.w / 2;
  const bottomY = y + player.h;

  if (player.invincible) {
    ctx.save();
    ctx.translate(centerX, y + player.h * 0.5);
    const pulse = 16 + Math.sin(frame / 5) * 8;
    const auraW = player.w * 2.2 + pulse;
    const auraH = player.h * 2.2 + pulse;
    const maxR = Math.max(auraW, auraH);
    const grad = ctx.createRadialGradient(0, 0, player.w * 0.2, 0, 0, maxR);
    const hueOffset = (frame * 5) % 360;
    const rainbow = [0, 45, 90, 150, 210, 270, 330];
    rainbow.forEach((hue, idx) => {
      const stop = idx / (rainbow.length - 1);
      const alpha = 0.55 - stop * 0.4;
      grad.addColorStop(stop, `hsla(${(hue + hueOffset) % 360}, 85%, 70%, ${Math.max(alpha, 0)})`);
    });
    grad.addColorStop(1, 'hsla(0, 0%, 100%, 0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(0, 0, auraW, auraH, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  ctx.save();
  ctx.translate(centerX, bottomY);

  const runFrame = Math.floor(frame / 4) % 4;
  const jumpOffset = player.grounded ? 0 : -5;
  const s = TILE_SIZE * 0.04;

  let legFL = 0, legFR = 0, legBL = 0, legBR = 0;
  if (!player.grounded) {
    legFL = -2*s; legFR = -4*s; legBL = 1*s; legBR = 3*s;
  } else {
    if (runFrame === 0) { legFL=0; legFR=0; legBL=0; legBR=0; }
    else if (runFrame === 1) { legFL=-2*s; legFR=2*s; legBL=2*s; legBR=-2*s; }
    else if (runFrame === 2) { legFL=0; legFR=0; legBL=0; legBR=0; }
    else { legFL=2*s; legFR=-2*s; legBL=-2*s; legBR=2*s; }
  }

  const wag = Math.sin(frame / 6) * (player.grounded ? 1.5 * s : 3 * s);
  ctx.fillStyle = '#FFFFFF';
  ctx.beginPath();
  const tailBaseX = -10*s;
  const tailBaseY = -12*s + jumpOffset;
  ctx.arc(tailBaseX + wag * 0.2, tailBaseY, 4*s, 0, Math.PI*2);
  ctx.arc(tailBaseX - 3*s + wag * 0.4, tailBaseY - 3*s - wag * 0.2, 5*s, 0, Math.PI*2);
  ctx.arc(tailBaseX + 2*s + wag, tailBaseY - 4*s + wag * 0.1, 4*s, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle = '#DDDDDD';
  ctx.fillRect(-8*s + legBL, -6*s + jumpOffset, 3*s, 6*s);
  ctx.fillRect(4*s + legFL, -6*s + jumpOffset, 3*s, 6*s);

  ctx.fillStyle = '#C62828';
  ctx.beginPath();
  if (ctx.roundRect) {
    ctx.roundRect(-10*s, -16*s + jumpOffset, 20*s, 12*s, 4*s);
  } else {
    ctx.rect(-10*s, -16*s + jumpOffset, 20*s, 12*s);
  }
  ctx.fill();

  ctx.fillStyle = '#FFFFFF';
  ctx.fillRect(-8*s, -14*s + jumpOffset, 16*s, 3*s);
  ctx.fillStyle = '#1565C0';
  ctx.fillRect(-8*s, -11*s + jumpOffset, 16*s, 3*s);
  ctx.fillStyle = '#B71C1C';
  ctx.fillRect(4*s, -16*s + jumpOffset, 4*s, 8*s);

  ctx.fillStyle = '#FFFFFF';
  ctx.fillRect(-10*s + legBR, -6*s + jumpOffset, 3*s, 6*s);
  ctx.fillRect(6*s + legFR, -6*s + jumpOffset, 3*s, 6*s);

  const headX = 6*s;
  const headY = -20*s + jumpOffset;

  ctx.fillStyle = '#FFFFFF';
  ctx.beginPath();
  ctx.moveTo(headX - 2*s, headY);
  ctx.lineTo(headX - 6.5*s, headY - 13*s);
  ctx.lineTo(headX + 2.8*s, headY - 2.4*s);
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(headX + 2*s, headY);
  ctx.lineTo(headX + 7*s, headY - 13*s);
  ctx.lineTo(headX + 5.2*s, headY);
  ctx.fill();

  ctx.fillStyle = '#FFC0CB';
  ctx.beginPath();
  ctx.moveTo(headX - 2*s, headY - 1*s);
  ctx.lineTo(headX - 5.2*s, headY - 10.5*s);
  ctx.lineTo(headX + 1.8*s, headY - 2.8*s);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(headX + 2.5*s, headY - 1*s);
  ctx.lineTo(headX + 6*s, headY - 10.5*s);
  ctx.lineTo(headX + 5*s, headY - 1*s);
  ctx.fill();

  ctx.fillStyle = '#FFFFFF';
  ctx.beginPath();
  ctx.arc(headX, headY, 7*s, 0, Math.PI*2);
  ctx.fill();

  ctx.beginPath();
  ctx.arc(headX + 5*s, headY + 1*s, 3.5*s, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle = '#000000';
  ctx.beginPath();
  ctx.arc(headX + 2*s, headY - 1*s, 2*s, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle = '#FFFFFF';
  ctx.beginPath();
  ctx.arc(headX + 2.5*s, headY - 1.5*s, 0.6*s, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle = '#ff7aa2';
  ctx.beginPath();
  ctx.arc(headX + 7.5*s, headY + 0.5*s, 1*s, 0, Math.PI*2);
  ctx.fill();

  ctx.restore();
}

function drawBlock(ctx, x, y, type) {
  if (type === 1) { // Ground
    ctx.fillStyle = COLORS.ground;
    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
    ctx.fillStyle = COLORS.groundDark;
    ctx.fillRect(x, y + TILE_SIZE - 4, TILE_SIZE, 4);
  } else if (type === 2) { // Sushi treat
    const sushiW = TILE_SIZE * 0.8;
    const riceH = TILE_SIZE * 0.35;
    const fishH = TILE_SIZE * 0.25;
    const baseX = x + TILE_SIZE * 0.1;
    const riceY = y + TILE_SIZE * 0.45;
    const fishY = y + TILE_SIZE * 0.18;
    const radius = riceH * 0.5;

    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.2)';
    ctx.shadowBlur = 6;
    ctx.shadowOffsetY = 3;

    ctx.beginPath();
    ctx.moveTo(baseX + radius, riceY);
    ctx.lineTo(baseX + sushiW - radius, riceY);
    ctx.quadraticCurveTo(baseX + sushiW, riceY, baseX + sushiW, riceY + radius);
    ctx.lineTo(baseX + sushiW, riceY + riceH - radius);
    ctx.quadraticCurveTo(baseX + sushiW, riceY + riceH, baseX + sushiW - radius, riceY + riceH);
    ctx.lineTo(baseX + radius, riceY + riceH);
    ctx.quadraticCurveTo(baseX, riceY + riceH, baseX, riceY + riceH - radius);
    ctx.lineTo(baseX, riceY + radius);
    ctx.quadraticCurveTo(baseX, riceY, baseX + radius, riceY);
    ctx.closePath();
    ctx.fillStyle = '#fffdf5';
    ctx.fill();
    ctx.strokeStyle = '#e5ddd2';
    ctx.lineWidth = Math.max(1, TILE_SIZE * 0.04);
    ctx.stroke();

    ctx.fillStyle = '#1f3b2d';
    ctx.fillRect(baseX + sushiW * 0.35, fishY - fishH * 0.15, sushiW * 0.3, riceH + fishH * 1.1);

    ctx.beginPath();
    ctx.moveTo(baseX + riceH * 0.6, fishY);
    ctx.lineTo(baseX + sushiW - riceH * 0.6, fishY);
    ctx.quadraticCurveTo(baseX + sushiW, fishY + fishH * 0.5, baseX + sushiW - riceH * 0.4, fishY + fishH);
    ctx.lineTo(baseX + riceH * 0.4, fishY + fishH);
    ctx.quadraticCurveTo(baseX, fishY + fishH * 0.5, baseX + riceH * 0.6, fishY);
    ctx.closePath();
    ctx.fillStyle = '#ff6b6b';
    ctx.fill();

    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
    ctx.lineWidth = Math.max(1, TILE_SIZE * 0.025);
    for (let i = 0; i < 3; i++) {
      const stripeX = baseX + sushiW * (0.25 + i * 0.2);
      ctx.beginPath();
      ctx.moveTo(stripeX, fishY + fishH * 0.15);
      ctx.lineTo(stripeX - TILE_SIZE * 0.1, fishY + fishH * 0.85);
      ctx.stroke();
    }

    ctx.restore();
  } else if (type === 3) { // Pipe
    ctx.fillStyle = COLORS.pipe;
    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
    ctx.fillStyle = COLORS.pipeDark;
    ctx.fillRect(x + TILE_SIZE*0.1, y, TILE_SIZE*0.2, TILE_SIZE);
  } else if (type === 5) { // Question block
    ctx.fillStyle = COLORS.blockQ;
    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
    ctx.strokeStyle = '#8fbc8f';
    ctx.lineWidth = Math.max(1, TILE_SIZE * 0.06);
    ctx.strokeRect(x + TILE_SIZE * 0.08, y + TILE_SIZE * 0.08, TILE_SIZE * 0.84, TILE_SIZE * 0.84);
    ctx.fillStyle = '#ee82ee';
    ctx.font = `${Math.floor(TILE_SIZE * 0.6)}px 'M PLUS Rounded 1c', sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('?', x + TILE_SIZE * 0.5, y + TILE_SIZE * 0.52);
  } else if (type === 6) { // Heart item
    const cx = x + TILE_SIZE * 0.5;
    const cy = y + TILE_SIZE * 0.52;
    const r = TILE_SIZE * 0.28;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(1, 1.2);
    ctx.fillStyle = '#ff6b8a';
    ctx.beginPath();
    ctx.arc(-r * 0.55, -r * 0.1, r * 0.6, Math.PI, 0);
    ctx.arc(r * 0.55, -r * 0.1, r * 0.6, Math.PI, 0);
    ctx.lineTo(0, r * 1.35);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  } else if (type === 7) { // Used block
    ctx.fillStyle = '#d0a873';
    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
    ctx.strokeStyle = '#9b7748';
    ctx.lineWidth = Math.max(1, TILE_SIZE * 0.05);
    ctx.strokeRect(x + TILE_SIZE * 0.1, y + TILE_SIZE * 0.1, TILE_SIZE * 0.8, TILE_SIZE * 0.8);
  } else if (type === 4) { // Skull hazard
    ctx.save();
    ctx.translate(x + TILE_SIZE * 0.5, y + TILE_SIZE * 0.5);
    const skullSize = TILE_SIZE * 0.32;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = TILE_SIZE * 0.165;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(-skullSize * 1.05, skullSize * 1.05);
    ctx.lineTo(skullSize * 1.05, -skullSize * 1.05);
    ctx.moveTo(-skullSize * 1.05, -skullSize * 1.05);
    ctx.lineTo(skullSize * 1.05, skullSize * 1.05);
    ctx.stroke();
    ctx.fillStyle = '#2b1c34';
    ctx.beginPath();
    ctx.arc(0, 0, skullSize * 0.7, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#f4f4f4';
    ctx.beginPath();
    ctx.arc(0, 0, skullSize * 0.65, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#2b1c34';
    ctx.beginPath();
    ctx.arc(-skullSize * 0.35, -skullSize * 0.1, skullSize * 0.25, 0, Math.PI * 2);
    ctx.arc(skullSize * 0.35, -skullSize * 0.1, skullSize * 0.25, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillRect(-skullSize * 0.25, skullSize * 0.35, skullSize * 0.15, skullSize * 0.28);
    ctx.fillRect(-skullSize * 0.02, skullSize * 0.35, skullSize * 0.15, skullSize * 0.28);
    ctx.fillRect(skullSize * 0.2, skullSize * 0.35, skullSize * 0.15, skullSize * 0.28);
    ctx.restore();
  }
}

function drawBoo(ctx, x, y) {
  const r = TILE_SIZE * 0.34;
  ctx.save();
  ctx.fillStyle = '#ffffff';
  ctx.strokeStyle = '#d7d7d7';
  ctx.lineWidth = Math.max(1, TILE_SIZE * 0.04);
  ctx.beginPath();
  ctx.arc(x, y, r, Math.PI, 0);
  ctx.lineTo(x + r, y + r * 1.2);
  ctx.quadraticCurveTo(x + r * 0.5, y + r * 1.55, x, y + r * 1.2);
  ctx.quadraticCurveTo(x - r * 0.5, y + r * 1.55, x - r, y + r * 1.2);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = '#2b2b2b';
  ctx.beginPath();
  ctx.ellipse(x - r * 0.35, y + r * 0.15, r * 0.22, r * 0.3, 0, 0, Math.PI * 2);
  ctx.ellipse(x + r * 0.35, y + r * 0.15, r * 0.22, r * 0.3, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#ff7aa2';
  ctx.beginPath();
  ctx.arc(x, y + r * 0.6, r * 0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawRabbit(ctx, x, y, frame) {
  const arcMin = 0.5;
  ctx.save();
  ctx.translate(x + TILE_SIZE / 2, y + TILE_SIZE / 2);
  const p = { size: TILE_SIZE };
  ctx.fillStyle = '#f5deb3';
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.ellipse(0, p.size * 0.25, p.size * 0.5, p.size * 0.3, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
  ctx.beginPath();
  ctx.ellipse(0, -p.size * 0.1, p.size * 0.4, p.size * 0.28, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
  ctx.beginPath();
  ctx.ellipse(-p.size * 0.35, -p.size * 0.1, p.size * 0.16, p.size * 0.14, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
  ctx.beginPath();
  ctx.ellipse(p.size * 0.35, -p.size * 0.1, p.size * 0.16, p.size * 0.14, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
  ctx.fillStyle = '#3d3532';
  ctx.beginPath();
  ctx.ellipse(0, 0, p.size * 0.25, p.size * 0.1, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = 'black';
  ctx.beginPath();
  ctx.arc(-p.size * 0.15, -p.size * 0.12, Math.max(arcMin, p.size * 0.05), 0, Math.PI * 2);
  ctx.arc(p.size * 0.15, -p.size * 0.12, Math.max(arcMin, p.size * 0.05), 0, Math.PI * 2);
  ctx.arc(0, p.size * 0.02, Math.max(arcMin, p.size * 0.04), 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawEnemy(ctx, x, y, frame) {
  const w = TILE_SIZE;
  const h = TILE_SIZE;

  ctx.fillStyle = '#8B4513';

  ctx.beginPath();
  ctx.arc(x + w/2, y + h/2, w/2, 0, Math.PI, true);
  ctx.fill();

  ctx.fillStyle = '#CD853F';
  ctx.fillRect(x + w*0.3, y + h/2, w*0.4, h/2);

  ctx.fillStyle = '#FFF';
  ctx.beginPath();
  ctx.arc(x + w*0.4, y + h*0.6, w*0.1, 0, Math.PI*2);
  ctx.arc(x + w*0.6, y + h*0.6, w*0.1, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(x + w*0.42, y + h*0.6, w*0.04, 0, Math.PI*2);
  ctx.arc(x + w*0.62, y + h*0.6, w*0.04, 0, Math.PI*2);
  ctx.fill();

  if (Math.floor(frame / 10) % 2 === 0) {
    ctx.clearRect(x, y + h - 2, w, 2);
  }
}

function getEbiFlyY(ebi) {
  return ebi.baseY;
}

function drawEbiFly(ctx, x, y, frame) {
  const bodyLen = TILE_SIZE * 1.15;
  const bodyThick = TILE_SIZE * 0.38;
  const tailWidth = TILE_SIZE * 0.35;
  const tailHeight = TILE_SIZE * 0.32;
  const pixel = TILE_SIZE * 0.08;
  const wingFlap = Math.sin(frame * 0.4) * Math.PI / 32;

  ctx.save();
  ctx.translate(x, y);

  const drawWing = (offsetX, offsetY, flip) => {
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.rotate(flip * (Math.PI / 3.2 + wingFlap));
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.quadraticCurveTo(flip * bodyLen * 0.3, -bodyThick * 0.45, flip * bodyLen * 0.4, -bodyThick * 0.1);
    ctx.quadraticCurveTo(flip * bodyLen * 0.3, bodyThick * 0.3, 0, 0);
    ctx.fill();
    ctx.restore();
  };
  drawWing(0, -bodyThick * 0.45, -1);
  drawWing(bodyLen * 0.1, -bodyThick * 0.4, 1);

  ctx.fillStyle = '#f2a645';
  ctx.strokeStyle = '#a05f22';
  ctx.lineWidth = TILE_SIZE * 0.04;
  ctx.beginPath();
  ctx.moveTo(-bodyLen * 0.5, -bodyThick * 0.5);
  ctx.quadraticCurveTo(bodyLen * 0.2, -bodyThick * 0.6, bodyLen * 0.45, -bodyThick * 0.08);
  ctx.quadraticCurveTo(bodyLen * 0.38, bodyThick * 0.4, -bodyLen * 0.45, bodyThick * 0.55);
  ctx.quadraticCurveTo(-bodyLen * 0.55, bodyThick * 0.2, -bodyLen * 0.5, -bodyThick * 0.5);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = '#f8c977';
  for (let row = -2; row <= 2; row++) {
    for (let col = -2; col <= 3; col++) {
      if ((row + col) % 2 === 0) {
        ctx.fillRect(-bodyLen * 0.35 + col * pixel * 0.9, row * pixel * 0.9, pixel, pixel);
      }
    }
  }

  ctx.fillStyle = '#c86a2d';
  ctx.strokeStyle = '#7a3a14';
  ctx.beginPath();
  ctx.moveTo(bodyLen * 0.45, -tailHeight * 0.3);
  ctx.lineTo(bodyLen * 0.58, -tailHeight * 0.65);
  ctx.lineTo(bodyLen * 0.62, -tailHeight * 0.15);
  ctx.lineTo(bodyLen * 0.72, -tailHeight * 0.6);
  ctx.lineTo(bodyLen * 0.78, -tailHeight * 0.15);
  ctx.lineTo(bodyLen * 0.78, tailHeight * 0.15);
  ctx.lineTo(bodyLen * 0.72, tailHeight * 0.6);
  ctx.lineTo(bodyLen * 0.62, tailHeight * 0.15);
  ctx.lineTo(bodyLen * 0.58, tailHeight * 0.65);
  ctx.lineTo(bodyLen * 0.45, tailHeight * 0.3);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  ctx.restore();
}

function drawBaseball(ctx, x, y, r, spin) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(spin);
  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#c73b3b';
  ctx.lineWidth = Math.max(1, r * 0.18);
  ctx.beginPath();
  ctx.arc(-r * 0.3, 0, r * 0.85, -0.6, 0.6);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(r * 0.3, 0, r * 0.85, Math.PI - 0.6, Math.PI + 0.6);
  ctx.stroke();
  ctx.restore();
}

function triggerBaseballStorm() {
  const count = Math.max(60, Math.min(160, Math.floor((view.w * view.h) / 7000)));
  baseballStorm = { timer: BASEBALL_STORM_FRAMES, balls: [] };
  for (let i = 0; i < count; i++) {
    const r = TILE_SIZE * (0.14 + Math.random() * 0.18);
    baseballStorm.balls.push({
      x: Math.random() * view.w,
      y: Math.random() * view.h,
      r,
      vx: (Math.random() - 0.5) * 1.2,
      vy: (Math.random() - 0.5) * 1.2,
      spin: Math.random() * Math.PI
    });
  }
}

function drawBaseballStorm(ctx) {
  if (!baseballStorm) return;
  baseballStorm.balls.forEach(ball => {
    ball.x += ball.vx;
    ball.y += ball.vy;
    if (ball.x < -ball.r) ball.x = view.w + ball.r;
    if (ball.x > view.w + ball.r) ball.x = -ball.r;
    if (ball.y < -ball.r) ball.y = view.h + ball.r;
    if (ball.y > view.h + ball.r) ball.y = -ball.r;
    drawBaseball(ctx, ball.x, ball.y, ball.r, ball.spin);
  });
  baseballStorm.timer--;
  if (baseballStorm.timer <= 0) baseballStorm = null;
}

function drawBackground(ctx) {
  ctx.fillStyle = COLORS.sky;
  ctx.fillRect(0, 0, view.w, view.h);

  ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';

  const cloud = (cx, cy, s) => {
    ctx.beginPath();
    ctx.arc(cx, cy, 30 * s, 0, Math.PI * 2);
    ctx.arc(cx + 40 * s, cy + 10 * s, 40 * s, 0, Math.PI * 2);
    ctx.arc(cx - 40 * s, cy + 10 * s, 40 * s, 0, Math.PI * 2);
    ctx.fill();
  };

  const offset = gameState.cameraX * 0.2;
  const w = view.w + 400;

  for(let i = 0; i < 3; i++) {
    let x = (200 + i * 500 - offset) % w;
    if (x < -200) x += w;
    cloud(x, 150 + (i%2)*50, 1.0 + (i%2)*0.2);
  }
}

function drawBigBangEffect(ctx, t) {
  const progress = 1 - t;
  const cx = view.w * 0.5;
  const cy = view.h * 0.5;
  const maxR = Math.max(view.w, view.h) * (0.5 + progress * 1.6);
  const fade = Math.min(1, t);

  ctx.save();
  ctx.globalCompositeOperation = 'screen';

  const core = ctx.createRadialGradient(cx, cy, 0, cx, cy, maxR * 0.6);
  core.addColorStop(0, `rgba(255,255,255,${1.0 * fade})`);
  core.addColorStop(0.35, `rgba(255,245,210,${0.9 * fade})`);
  core.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = core;
  ctx.fillRect(0, 0, view.w, view.h);

  const halo = ctx.createRadialGradient(cx, cy, maxR * 0.2, cx, cy, maxR);
  halo.addColorStop(0, `rgba(255,255,255,${0.6 * fade})`);
  halo.addColorStop(0.7, `rgba(200,240,255,${0.35 * fade})`);
  halo.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = halo;
  ctx.fillRect(0, 0, view.w, view.h);

  const ringR = maxR * (0.3 + progress * 0.6);
  ctx.strokeStyle = `rgba(255,255,255,${0.7 * fade})`;
  ctx.lineWidth = Math.max(2, view.w * 0.01);
  ctx.beginPath();
  ctx.arc(cx, cy, ringR, 0, Math.PI * 2);
  ctx.stroke();

  ctx.fillStyle = `rgba(255,255,255,${0.45 * fade})`;
  ctx.fillRect(0, 0, view.w, view.h);
  ctx.restore();
}

/**
 * Game Logic
 */
class Level {
  constructor() {
    this.map = {};
    this.enemies = [];
    this.ebiFlies = [];
    this.boos = [];
    this.generatedX = 0;
    this.groundY = 10;
    this.gapCooldown = 0;
    this.gapRemaining = 0;
    this.avoidPipeNext = 0;
    this.rabbitSpawned = new Set();

    // ÂàùÂõûÁîüÊàêÁØÑÂõ≤„ÇíÂ∫É„ÅèÂèñ„ÇãÔºàÁîªÈù¢ÂπÖ„ÅÆ3ÂÄçÔºâ
    this.updateMap(view.w * 3);
  }

  updateMap(targetX) {
    // ÂÖàË™≠„ÅøÁØÑÂõ≤„ÇíÂ∫É„ÇÅ„Å´ (+50)
    const targetTileX = Math.ceil(targetX / TILE_SIZE) + 50;

    // ÁîüÊàê
    while (this.generatedX < targetTileX) {
      this.generateColumn(this.generatedX);
      this.generatedX++;
    }

    // „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
    const deleteThreshold = Math.floor((gameState.cameraX - view.w) / TILE_SIZE);
    this.enemies = this.enemies.filter(e => e.x > gameState.cameraX - view.w);
    this.ebiFlies = this.ebiFlies.filter(e => !e.collected && e.x > gameState.cameraX - view.w * 1.2);
    this.rabbitSpawned.forEach((colX) => {
      if (colX < deleteThreshold) this.rabbitSpawned.delete(colX);
    });

    // Âè§„ÅÑ„Éû„ÉÉ„Éó„Éá„Éº„Çø„ÅÆÂâäÈô§ÔºàËªΩÈáèÂåñÔºâ
    if (this.generatedX % 100 === 0) {
      for (let x in this.map) {
        if (parseInt(x) < deleteThreshold) {
          delete this.map[x];
        }
      }
    }
  }

  generateColumn(x) {
    this.map[x] = [];
    // ÂàùÊúüÂåñ: ÂÖ®„Å¶„Çí0(Á©∫Ê∞ó)„Å´„Åô„Çã
    for(let y=0; y<ROWS; y++) this.map[x][y] = 0;

    // „Çπ„Çø„Éº„ÉàÂú∞ÁÇπ„ÄúÂÆâÂÖ®Âúè
    if (x < 30) {
      for(let y=this.groundY; y<ROWS; y++) this.map[x][y] = 1;
      return;
    }

    // „ÇØ„Éº„É´„ÉÄ„Ç¶„É≥Âá¶ÁêÜÔºàÁ©¥„ÅÆÁõ¥ÂæåÔºâ
    if (this.gapCooldown > 0) {
      this.gapCooldown--;
      for(let y=this.groundY; y<ROWS; y++) this.map[x][y] = 1;

      // „ÇØ„Éº„É´„ÉÄ„Ç¶„É≥‰∏≠„ÇÇ„Ç¢„Ç§„ÉÜ„É†Á≠â„ÅØÂá∫„Åó„Å¶OK
      this.generateObjects(x, this.groundY);
      return;
    }

    // Êñ∞„Åó„ÅÑÁ©¥„ÅÆÁîüÊàêÂà§ÂÆö
    if (this.gapRemaining <= 0 && Math.random() < 0.0) {
      const gapWidth = Math.floor(Math.random() * 2) + 2; // 2~3„Éû„Çπ
      this.gapRemaining = gapWidth;
      this.gapCooldown = gapWidth + 5; // „Ç∏„É£„É≥„ÉóÂæåÁùÄÂú∞„Çπ„Éö„Éº„ÇπÁ¢∫‰øù

      // Á©¥„ÅÆÂêë„Åì„ÅÜÂÅ¥„ÅÆÈ´ò„Åï„Çí„Åì„Åì„ÅßÊ±∫„ÇÅ„Å¶„Åä„Åè
      if (Math.random() < 0.5) {
        const diff = Math.floor(Math.random() * 3) - 1;
        this.groundY += diff;
        this.groundY = Math.max(7, Math.min(13, this.groundY));
      }
    }

    // Á©¥ÁîüÊàê‰∏≠
    if (this.gapRemaining > 0) {
      this.gapRemaining--;
      return; // Âú∞Èù¢ÁîüÊàê„Åó„Å™„ÅÑ
    }

    // Âú∞Èù¢„ÅÆÈ´ò„Åï„Çí„Åü„Åæ„Å´Â§â„Åà„Çã
    if (Math.random() < 0.05) {
      this.groundY += Math.random() > 0.5 ? 1 : -1;
      this.groundY = Math.max(7, Math.min(13, this.groundY));
    }

    // Âú∞Èù¢ÁîüÊàê
    for(let y=this.groundY; y<ROWS; y++) this.map[x][y] = 1;

    // „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÈÖçÁΩÆ
    this.generateObjects(x, this.groundY);
  }

  generateObjects(x, groundY) {
    const avoidPipeThisColumn = this.avoidPipeNext > 0;
    if (this.avoidPipeNext > 0) this.avoidPipeNext--;
    const canPlacePipe = !avoidPipeThisColumn;
    if (Math.random() < 0.05) {
      // Âú∞‰∏ä„ÅÆÈöúÂÆ≥Áâ©
      if (Math.random() > 0.5 && canPlacePipe) {
        this.map[x][groundY-1] = 3;
      } else {
        this.map[x][groundY-1] = 2;
      }
    } else if (Math.random() < 0.05) {
      // Á©∫‰∏≠„ÅÆË∂≥Â†¥
      this.map[x][groundY-4] = 2;
    } else if (Math.random() < 0.04) {
      // ?„Éñ„É≠„ÉÉ„ÇØ
      const blockY = groundY - 4;
      if (blockY > 1) {
        this.map[x][blockY] = 5;
        this.avoidPipeNext = 1;
      }
    }


    if (Math.random() < 0.012) {
      this.map[x][groundY-2] = 4;
    }

    // Êïµ
    if (Math.random() < 0.03) {
      this.enemies.push({
        x: x * TILE_SIZE,
        y: (groundY - 1) * TILE_SIZE,
        active: true
      });
    }

    if (Math.random() < 0.0075) {
      const ebx = x * TILE_SIZE + view.w + TILE_SIZE * 2;
      const eby = Math.max(2, groundY - 6) * TILE_SIZE;
      this.ebiFlies.push({
        x: ebx,
        baseY: eby,
        amplitude: 0,
        phase: 0,
        speed: TILE_SIZE * (0.08 + Math.random() * 0.04),
        collected: false
      });
    }
  }

  draw(ctx, frame) {
    const startCol = Math.floor(gameState.cameraX / TILE_SIZE);
    // ÊèèÁîªÁØÑÂõ≤„ÇíÂ∞ë„ÅóÂ∫É„ÇÅ„Å´Âèñ„ÇãÔºà„ÉÅ„É©„Å§„ÅçÈò≤Ê≠¢Ôºâ
    const endCol = startCol + Math.ceil(view.w / TILE_SIZE) + 4;

    for (let x = startCol; x < endCol; x++) {
      if (!this.map[x]) continue;
      for (let y = 0; y < ROWS; y++) {
        const type = this.map[x][y];
        if (type && type !== 0) {
          drawBlock(ctx, x * TILE_SIZE - gameState.cameraX, y * TILE_SIZE, type);
        }
      }
    }

    this.boos.forEach(boo => {
      const floatX = boo.baseX + Math.sin(boo.age * 0.2 + boo.phase) * TILE_SIZE * 0.3;
      const screenX = floatX - gameState.cameraX;
      if (screenX < -TILE_SIZE || screenX > view.w + TILE_SIZE) return;
      drawBoo(ctx, screenX, boo.y);
    });

    this.enemies.forEach(e => {
      if (e.active && e.x > gameState.cameraX - TILE_SIZE && e.x < gameState.cameraX + view.w) {
        if (e.type === 'rabbit') {
          drawRabbit(ctx, e.x - gameState.cameraX, e.y, frame);
        } else {
          drawEnemy(ctx, e.x - gameState.cameraX, e.y, frame);
        }
      }
    });

    this.ebiFlies.forEach(ebi => {
      if (ebi.collected) return;
      const screenX = ebi.x - gameState.cameraX;
      if (screenX < -TILE_SIZE || screenX > view.w + TILE_SIZE) return;
      const renderY = getEbiFlyY(ebi);
      drawEbiFly(ctx, screenX, renderY, frame);
    });
  }

  isSolid(x, y) {
    if (x < 0) return true;
    if (!this.map[x]) return false;
    if (y < 0 || y >= ROWS) return false;
    return this.map[x][y] !== undefined && this.map[x][y] !== 0;
  }
}

let player = {
  x: 0, y: 0, vx: 0, vy: 0, w: 0, h: 0, grounded: false, dead: false, invincible: false, invincibleTimer: 0
};

let level;
let animationId;
let frameCount = 0;

function setOverlayState(state, scoreValue = 0) {
  if (state === 'start') {
    overlayScene.style.display = 'block';
    if (overlayVideo) {
      overlayVideo.style.display = 'block';
      const videoEl = overlayVideo.querySelector('video');
      if (videoEl && videoEl.paused) videoEl.play().catch(() => {});
    }
    // opening sound removed
    overlayMessageEl.innerText = '';
    overlayMessageEl.style.display = 'none';
    overlaySubheadEl.innerHTML = '';
    overlaySubheadEl.style.display = 'none';
    overlaySubtextEl.innerText = '';
    overlaySubtextEl.style.display = 'none';
    overlayScorePanel.classList.remove('visible');
    startBtn.innerText = 'START!';
  } else if (state === 'gameover') {
    overlayScene.style.display = 'none';
    if (overlayVideo) {
      overlayVideo.style.display = 'none';
      const videoEl = overlayVideo.querySelector('video');
      if (videoEl) videoEl.pause();
    }
    // opening sound removed
    overlayMessageEl.innerText = 'GAME OVER';
    overlayMessageEl.style.display = 'block';
    overlaySubheadEl.innerHTML = `<img src="assets/pyon-pyon-rosetsu:assets:ref:ui_reference_01.png" alt="dog face">„ÇØ„Ç•„Äú„É≥„ÄÅ„ÄÅ`;
    overlaySubheadEl.style.display = 'block';
    overlaySubtextEl.innerText = '';
    overlaySubtextEl.style.display = 'none';
    overlayScoreValue.innerText = scoreValue;
    overlayScorePanel.classList.add('visible');
    startBtn.innerText = '„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÉÅ„É£„É¨„É≥„Ç∏„Åô„Çã';
  }
}

function init() {
  // „Ç≤„Éº„É†ÈñãÂßãÊôÇ: „Åì„Åì„ÅßÁîªÈù¢„Çµ„Ç§„Ç∫„Å´Âêà„Çè„Åõ„Å¶ÂÆöÊï∞„ÇíÁ¢∫ÂÆö„Åï„Åõ„Çã
  resize();
  calculateConstants();

  // opening sound removed
  baseballStorm = null;
  dogSpawnCooldown = 0;

  player.w = TILE_SIZE * 1.3;
  player.h = TILE_SIZE * 1.1;
  player.x = TILE_SIZE * 4;
  player.y = TILE_SIZE * 5;
  player.vx = MOVE_SPEED;
  player.vy = 0;
  player.dead = false;
  player.invincible = false;
  player.invincibleTimer = 0;

  level = new Level();
  gameState.score = 0;
  gameState.distance = 0;
  gameState.cameraX = 0;
  gameState.isRunning = true;
  jumpPressed = false;

  startScreenEl.style.display = 'none';

  gameLoop();
}

function updatePhysics() {
  if (player.dead) {
    player.vy += GRAVITY;
    player.y += player.vy;
    return;
  }

  // „Éû„ÉÉ„ÉóÊõ¥Êñ∞: ÁîªÈù¢Â§ñ„ÇÇ‰ΩôË£ï„ÇíÊåÅ„Å£„Å¶ÁîüÊàê
  level.updateMap(player.x + view.w);
  if (dogSpawnCooldown > 0) dogSpawnCooldown--;

  const spawnRabbitFromPipe = (colX, pipeY) => {
    const rabbitY = pipeY * TILE_SIZE;
    level.enemies.push({
      x: colX * TILE_SIZE,
      y: rabbitY,
      baseY: rabbitY,
      active: true,
      type: 'rabbit',
      emergeFrames: RABBIT_EMERGE_FRAMES,
      emergeDuration: RABBIT_EMERGE_FRAMES,
      vx: -MOVE_SPEED * 0.25
    });
  };

  const startCol = Math.floor(gameState.cameraX / TILE_SIZE);
  const endCol = startCol + Math.ceil(view.w / TILE_SIZE) + 1;
  for (let x = startCol; x <= endCol; x++) {
    if (level.rabbitSpawned.has(x)) continue;
    if (dogSpawnCooldown > 0) continue;
    const column = level.map[x];
    if (!column) continue;
    const pipeY = column.findIndex(tile => tile === 3);
    if (pipeY === -1) continue;
    const screenX = x * TILE_SIZE - gameState.cameraX;
    if (screenX < 0 || screenX > view.w - TILE_SIZE * 0.5) continue;
    level.rabbitSpawned.add(x);
    if (Math.random() < RABBIT_SPAWN_CHANCE) {
      spawnRabbitFromPipe(x, pipeY);
    }
  }

  player.vx = MOVE_SPEED;

  if (jumpPressed && player.grounded) {
    player.vy = JUMP_FORCE;
    player.grounded = false;
    jumpPressed = false;
  }

  player.vy += player.invincible ? GRAVITY * 0.35 : GRAVITY;
  const prevX = player.x;
  player.x += player.vx;
  player.y += player.vy;

  level.enemies.forEach(e => {
    if (!e.active || e.type !== 'rabbit') return;
    if (e.emergeFrames > 0) {
      e.emergeFrames--;
      const progress = 1 - e.emergeFrames / e.emergeDuration;
      e.y = e.baseY + TILE_SIZE * 0.3 - progress * TILE_SIZE * 0.3;
      return;
    }
    e.y = e.baseY;
    e.x += e.vx;
  });

  level.ebiFlies.forEach(ebi => {
    if (!ebi.collected) {
      ebi.x -= ebi.speed;
    }
  });

  if (level.boos.length) {
    level.boos = level.boos.filter(boo => {
      boo.age += 1;
      boo.y -= TILE_SIZE * 0.05;
      return boo.y > -TILE_SIZE * 2;
    });
  }

  if (player.invincible) {
    player.invincibleTimer--;
    if (player.invincibleTimer <= 0) {
      player.invincibleTimer = 0;
      player.invincible = false;
      if (player.y > view.h + 100) {
        die();
        return;
      }
    }
  }

  gameState.distance = Math.floor(player.x / TILE_SIZE);
  distEl.innerText = `${gameState.distance}`;

  player.grounded = false;

  const getTile = (px, py) => ({
    x: Math.floor(px / TILE_SIZE),
    y: Math.floor(py / TILE_SIZE)
  });

const collectItemAt = (tile) => {
  const column = level.map[tile.x];
  if (!column) return false;
  if (column[tile.y] === 2 || column[tile.y] === 6) {
    const addScore = column[tile.y] === 2 ? 50 : 0;
    column[tile.y] = 0;
    gameState.score += addScore;
    scoreEl.innerText = `SCORE: ${gameState.score}`;
    return true;
  }
  return false;
};

const handleQuestionBlockAt = (tile) => {
  const column = level.map[tile.x];
  if (!column) return false;
  if (column[tile.y] === 5) {
    column[tile.y] = 7;
    const aboveY = tile.y - 1;
    if (aboveY >= 0 && column[aboveY] === 0) {
      const spawnBoo = Math.random() < 0.2;
      if (spawnBoo) {
        level.boos.push({
          baseX: tile.x * TILE_SIZE + TILE_SIZE * 0.5,
          y: (aboveY + 0.5) * TILE_SIZE,
          age: 0,
          phase: Math.random() * Math.PI * 2
        });
      } else {
        column[aboveY] = 6;
      }
    }
    gameState.score += 20;
    scoreEl.innerText = `SCORE: ${gameState.score}`;
    return true;
  }
  return false;
};

const handleSkullAt = (tile, allowStomp = false) => {
  const column = level.map[tile.x];
  if (!column) return 'none';
  if (column[tile.y] === 4) {
    if (allowStomp && player.vy > 0) {
      column[tile.y] = 0;
      player.vy = JUMP_FORCE * 0.4;
      gameState.score += 80;
      scoreEl.innerText = `SCORE: ${gameState.score}`;
      return 'stomped';
    }
    column[tile.y] = 0;
    die();
    return 'dead';
  }
  return 'none';
};

  // Êé•Âú∞Âà§ÂÆö
  if (player.vy >= 0) {
    const bl = getTile(player.x + 5, player.y + player.h);
    const br = getTile(player.x + player.w - 5, player.y + player.h);

    if (level.isSolid(bl.x, bl.y) || level.isSolid(br.x, br.y)) {
      const skullLeft = handleSkullAt(bl, true);
      if (skullLeft === 'dead') return;
      const skullRight = handleSkullAt(br, true);
      if (skullRight === 'dead') return;
      let collected = false;
      if (collectItemAt(bl)) collected = true;
      if (collectItemAt(br)) collected = true;

      if (!collected && (level.isSolid(bl.x, bl.y) || level.isSolid(br.x, br.y))) {
        const groundTile = level.isSolid(bl.x, bl.y) ? bl : br;
        const blockTop = groundTile.y * TILE_SIZE;
        if (player.y + player.h <= blockTop + player.vy + TILE_SIZE/2) {
          player.y = blockTop - player.h;
          player.vy = 0;
          player.grounded = true;
        }
      }
    }
  } else {
    const tl = getTile(player.x + 5, player.y);
    const tr = getTile(player.x + player.w - 5, player.y);
    if (level.isSolid(tl.x, tl.y) || level.isSolid(tr.x, tr.y)) {
      const skullTopLeft = handleSkullAt(tl, false);
      if (skullTopLeft === 'dead') return;
      const skullTopRight = handleSkullAt(tr, false);
      if (skullTopRight === 'dead') return;
      const hitQuestion = handleQuestionBlockAt(tl) || handleQuestionBlockAt(tr);
      let collected = false;
      if (collectItemAt(tl)) collected = true;
      if (collectItemAt(tr)) collected = true;

      if (!collected && (level.isSolid(tl.x, tl.y) || level.isSolid(tr.x, tr.y) || hitQuestion)) {
        player.y = (tl.y + 1) * TILE_SIZE;
        player.vy = 0;
      }
    }
  }

  // Ë°ùÁ™ÅÂà§ÂÆöÔºàÂè≥ÂÅ¥Ôºâ
  const tr = getTile(player.x + player.w, player.y + 5);
  const br = getTile(player.x + player.w, player.y + player.h - 5);

  const checkHit = (tile) => {
    if (!level.isSolid(tile.x, tile.y)) return false;
    const skullRes = handleSkullAt(tile);
    if (skullRes === 'dead') return true;
    if (collectItemAt(tile)) return false;
    const column = level.map[tile.x];
    if (!column) return false;
    const type = column[tile.y];

    if (type === 1 || type === 3 || type === 5 || type === 7) {
      player.x = prevX;
      return false;
    }

    return true;
  };

  const hitTop = checkHit(tr);
  const hitBottom = checkHit(br);

  if (hitTop || hitBottom) {
    die();
  }

  level.ebiFlies = level.ebiFlies.filter(ebi => {
    if (ebi.collected) return false;
    const ebiY = getEbiFlyY(ebi);
    const half = TILE_SIZE * 0.45;
    if (player.x < ebi.x + half &&
        player.x + player.w > ebi.x - half &&
        player.y < ebiY + half &&
        player.y + player.h > ebiY - half) {
      ebi.collected = true;
      player.invincible = true;
      player.invincibleTimer = INVINCIBLE_DURATION_FRAMES;
      gameState.score += 150;
      scoreEl.innerText = `SCORE: ${gameState.score}`;
      return false;
    }
    if (ebi.x < gameState.cameraX - TILE_SIZE * 2) return false;
    return true;
  });

  // ËêΩ‰∏ãÊ≠ª
  if (!player.invincible && player.y > view.h + 100) die();

  // „Ç´„É°„É©ËøΩÂæì
  const targetCamX = player.x - view.w * 0.2;
  gameState.cameraX = targetCamX;
  if (gameState.cameraX < 0) gameState.cameraX = 0;

  // Êïµ„Å®„ÅÆÂΩì„Åü„ÇäÂà§ÂÆö
  level.enemies.forEach(e => {
    if(!e.active) return;

    if (player.x < e.x + TILE_SIZE &&
        player.x + player.w > e.x &&
        player.y < e.y + TILE_SIZE &&
        player.y + player.h > e.y) {
      if (e.type === 'rabbit') {
        e.active = false;
        bigBangTimer = BIG_BANG_DURATION_FRAMES;
        triggerBaseballStorm();
        dogSpawnCooldown = DOG_COOLDOWN_FRAMES;
        return;
      }

      if (player.invincible) {
        e.active = false;
        gameState.score += 120;
        scoreEl.innerText = `SCORE: ${gameState.score}`;
      } else if (player.vy > 0 && player.y + player.h < e.y + TILE_SIZE * 0.6) {
        e.active = false;
        player.vy = JUMP_FORCE * 0.6;
        gameState.score += 100;
        scoreEl.innerText = `SCORE: ${gameState.score}`;
      } else {
        die();
      }
    }
  });
}

function die() {
  if(player.dead) return;

  player.dead = true;
  player.invincible = false;
  player.invincibleTimer = 0;
  player.vy = JUMP_FORCE;
  const finalScore = gameState.score;

  setTimeout(() => {
    gameState.isRunning = false;
    setOverlayState('gameover', finalScore);
    startScreenEl.style.display = 'flex';
    gameState.score = 0;
    gameState.distance = 0;
    scoreEl.innerText = 'SCORE: 0';
    distEl.innerText = '0';
  }, 1500);
}

function gameLoop() {
  if (!gameState.isRunning) return;

  ctx.clearRect(0, 0, view.w, view.h);

  drawBackground(ctx);
  updatePhysics();
  level.draw(ctx, frameCount);
  drawPlayer(ctx, player.x - gameState.cameraX, player.y, frameCount);
  if (bigBangTimer > 0) {
    drawBigBangEffect(ctx, bigBangTimer / BIG_BANG_DURATION_FRAMES);
    bigBangTimer--;
  }
  drawBaseballStorm(ctx);

  frameCount++;
  animationId = requestAnimationFrame(gameLoop);
}

// „Éú„Çø„É≥„Ç§„Éô„É≥„Éà: „ÇØ„É™„ÉÉ„ÇØ„Å®„Çø„ÉÉ„ÉÅ‰∏°Êñπ„Å´ÂØæÂøú
startBtn.addEventListener('click', (e) => { e.preventDefault(); init(); });
startBtn.addEventListener('touchstart', (e) => { e.preventDefault(); init(); });
setOverlayState('start');

const container = document.getElementById('game-container');
const handleInput = (e) => {
  if(!gameState.isRunning) return;
  if(e.type !== 'mousedown') e.preventDefault(); // „Çø„ÉÉ„ÉÅÊôÇ„ÅÆÈáçË§á„Ç§„Éô„É≥„ÉàÈò≤Ê≠¢
  jumpPressed = true;
};
container.addEventListener('touchstart', handleInput, {passive: false});
container.addEventListener('mousedown', handleInput);

window.addEventListener('keydown', e => {
  if(e.code === 'Space' || e.key === 'ArrowUp') handleInput(e);
});
window.addEventListener('keyup', e => {
  if(e.code === 'Space' || e.key === 'ArrowUp') jumpPressed = false;
});

container.addEventListener('touchend', () => jumpPressed = false);
container.addEventListener('mouseup', () => jumpPressed = false);
</script>
</body>
</html>
